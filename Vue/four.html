<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vite | panda</title>
    <meta name="description" content="panda个人记录，记录各端的一些日常遇到或看到的技术点和问题；">
    <link rel="icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.62165e4e.css" as="style"><link rel="preload" href="/assets/js/app.a56db5c7.js" as="script"><link rel="preload" href="/assets/js/3.a1556db4.js" as="script"><link rel="preload" href="/assets/js/2.2a730d8e.js" as="script"><link rel="preload" href="/assets/js/4.cf994699.js" as="script"><link rel="prefetch" href="/assets/js/10.5b0a1bb4.js"><link rel="prefetch" href="/assets/js/11.8a9fca66.js"><link rel="prefetch" href="/assets/js/12.7b7c115e.js"><link rel="prefetch" href="/assets/js/13.fedc60b8.js"><link rel="prefetch" href="/assets/js/14.33a69659.js"><link rel="prefetch" href="/assets/js/15.1f951f91.js"><link rel="prefetch" href="/assets/js/16.2543c021.js"><link rel="prefetch" href="/assets/js/17.d5c41a79.js"><link rel="prefetch" href="/assets/js/18.d91df91a.js"><link rel="prefetch" href="/assets/js/5.48f06e81.js"><link rel="prefetch" href="/assets/js/6.e4240f40.js"><link rel="prefetch" href="/assets/js/7.72d54672.js"><link rel="prefetch" href="/assets/js/8.ef434f62.js"><link rel="prefetch" href="/assets/js/9.dda3a4f2.js">
    <link rel="stylesheet" href="/assets/css/0.styles.62165e4e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">panda</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Vue/" class="nav-link router-link-active">Vue</a></li><li class="dropdown-item"><!----> <a href="/Serverless/" class="nav-link">Serverless</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">移动端</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/iOS/" class="nav-link">iOS</a></li></ul></div></div><div class="nav-item"><a href="/Vue/.html" class="nav-link"></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Vue/" class="nav-link router-link-active">Vue</a></li><li class="dropdown-item"><!----> <a href="/Serverless/" class="nav-link">Serverless</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">移动端</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/iOS/" class="nav-link">iOS</a></li></ul></div></div><div class="nav-item"><a href="/Vue/.html" class="nav-link"></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Vue</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Vue/" class="sidebar-link">Vuejs建议和最佳实践</a></li><li><a href="/Vue/one.html" class="sidebar-link">Vue打包瘦身优化</a></li><li><a href="/Vue/two.html" class="sidebar-link">Vue-cli 3.0基础项目工程模板</a></li><li><a href="/Vue/three.html" class="sidebar-link">Vue的编码技巧与规范</a></li><li><a href="/Vue/four.html" class="active sidebar-link">Vite</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Vue/four.html#vite-实现" class="sidebar-link">Vite 实现</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Vue/four.html#请求拦截原理" class="sidebar-link">请求拦截原理</a></li><li class="sidebar-sub-header"><a href="/Vue/four.html#拦截-http-请求" class="sidebar-link">拦截 HTTP 请求</a></li></ul></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Serverless</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>其他</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>Vite（法语意思是 “快”，发音为 /vit/，类似 veet）是一种全新的前端构建工具。你可以把它理解为一个开箱即用的开发服务器 + 打包工具的组合，但是更轻更快。</p> <p>在浏览器支持 ES 模块之前，开发者没有以模块化的方式开发 JavaScript 的原生机制。这也是 “打包” 这个概念出现的原因：使用工具抓取、处理和链接我们的源码模块到文件中，使其可以运行在浏览器中。</p> <p>时过境迁，我们见证了许多诸如 webpack、Rollup 和 Gulp 等工具的诞生，这些工具极大地改善了前端开发者的开发体验。</p> <p>然而，当我们开始构建越来越大型的应用时，需要处理的 JavaScript 代码量也呈指数级增长。大型项目包含数千个模块的情况并不少见。我们开始遇到性能瓶颈 —— 使用 JavaScript 开发的工具通常需要很长时间（甚至是几分钟！）才能启动开发服务器，即使使用 HMR，文件修改后的效果也需要几秒钟才能在浏览器中反映出来。如此循环往复，迟钝的反馈会极大地影响开发者的开发效率和幸福感。</p> <p>Vite 旨在利用生态系统中的新进展解决上述问题：浏览器开始原生支持 ES 模块，越来越多 JavaScript 工具使用编译型语言编写。</p> <p><code>ES Modules 是浏览器支持的一种模块化方案，允许在代码中实现模块化</code></p> <h3 id="特点"><a href="#特点" aria-hidden="true" class="header-anchor">#</a> 特点</h3> <p>Lightning fast cold server start  - 闪电般的冷启动速度</p> <p>Instant hot module replacement (HMR) - 即时热模块更换（热更新）</p> <p>True on-demand compilation - 真正的按需编译</p> <p>一个是 Vite 主要对应的场景是开发模式，原理是拦截浏览器发出的 ES imports 请求并做相应处理。（生产模式是用 rollup 打包）
一个是 Vite 在开发模式下不需要打包，只需要编译浏览器发出的 HTTP 请求对应的文件即可，所以热更新速度很快。</p> <p>因此，要实现上述目标，需要要求项目里只使用原生 ES imports，如果使用了 require 将失效</p> <h3 id="缓慢的服务器启动"><a href="#缓慢的服务器启动" aria-hidden="true" class="header-anchor">#</a> 缓慢的服务器启动</h3> <p>当冷启动开发服务器时，基于打包器的方式是在提供服务前去急切地抓取和构建你的整个应用。</p> <p>Vite 通过在一开始将应用中的模块区分为 依赖 和 源码 两类，改进了开发服务器启动时间。</p> <p>依赖 大多为纯 JavaScript 并在开发时不会变动。一些较大的依赖（例如有上百个模块的组件库）处理的代价也很高。依赖也通常会以某些方式（例如 ESM 或者 CommonJS）被拆分到大量小模块中。</p> <p>Vite 将会使用 esbuild 预构建依赖。Esbuild 使用 Go 编写，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍。</p> <p>源码 通常包含一些并非直接是 JavaScript 的文件，需要转换（例如 JSX，CSS 或者 Vue/Svelte 组件），时常会被编辑。同时，并不是所有的源码都需要同时被加载。（例如基于路由拆分的代码模块）。</p> <p>Vite 以 原生 ESM 方式服务源码。这实际上是让浏览器接管了打包程序的部分工作：Vite 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景动态导入的代码，即只在当前屏幕上实际使用时才会被处理。</p> <h3 id="缓慢的更新"><a href="#缓慢的更新" aria-hidden="true" class="header-anchor">#</a> 缓慢的更新</h3> <p>当基于打包器启动时，编辑文件后将重新构建文件本身。显然我们不应该重新构建整个包，因为这样更新速度会随着应用体积增长而直线下降。</p> <p>一些打包器的开发服务器将构建内容存入内存，这样它们只需要在文件更改时使模块图的一部分失活[1]，但它也仍需要整个重新构建并重载页面。这样代价很高，并且重新加载页面会消除应用的当前状态，所以打包器支持了动态模块热重载（HMR）：允许一个模块 “热替换” 它自己，而对页面其余部分没有影响。这大大改进了开发体验 - 然而，在实践中我们发现，即使是 HMR 更新速度也会随着应用规模的增长而显著下降。</p> <p>在 Vite 中，HMR 是在原生 ESM 上执行的。当编辑一个文件时，Vite 只需要精确地使已编辑的模块与其最近的 HMR 边界之间的链失效（大多数时候只需要模块本身），使 HMR 更新始终快速，无论应用的大小。</p> <p>Vite 同时利用 HTTP 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：源码模块的请求会根据 304 Not Modified 进行协商缓存，而依赖模块请求则会通过 Cache-Control: max-age=31536000,immutable 进行强缓存，因此一旦被缓存它们将不需要再次请求。</p> <h3 id="浏览器兼容性："><a href="#浏览器兼容性：" aria-hidden="true" class="header-anchor">#</a> 浏览器兼容性：</h3> <p><img src="/assets/img/vue_vite_web.67be490e.png" alt=""></p> <h3 id="webpack-vite-原理对比"><a href="#webpack-vite-原理对比" aria-hidden="true" class="header-anchor">#</a> Webpack &amp; Vite 原理对比</h3> <p>webpack 打包时, 经常会因为一小行代码改动，就需要耗时数秒甚至十几秒进行重新打包；这是因为 webpack 需要将所有模块打包成一个一个或者多个模块
<img src="/assets/img/vue_webpack.5200f5f7.png" alt=""></p> <p>如下面的代码为例，当我们使用如 webpack 类的打包工具时。最终会将所有的代码打包入一个 bundle.js 文件中</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">// a.js </span>
<span class="token keyword">export</span> <span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">10</span>

<span class="token comment">// b.js </span>
<span class="token keyword">export</span> <span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>

<span class="token comment">// main.js </span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> a <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'a.js'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> b <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'b.js'</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">calculate</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// bundle.js</span>
<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">calculate</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> calculate <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>Webpack 的热更新原理简单来说就是，一旦发生某个依赖（比如上面的 a.js ）改变，就将这个依赖所处的 module 的更新，并将新的 module 发送给浏览器重新执行。由于我们只打了一个 bundle.js，所以热更新的话也会重新打这个 bundle.js。试想如果依赖越来越多，就算只修改一个文件，理论上热更新的速度也会越来越慢。</p> <p>用vite编译的话，最终产出的依然是 <code>a.js、b.js、c.js</code> 三个文件，只有编译耗时。由于入口是 <code>c.js</code>，浏览器解析到 <code>import { a } from './a'</code> 时，会发起 HTTP 请求 a.js （b 同理），就算不用打包，也可以加载到所需要的代码，因此省去了合并代码的时间。
在热更新的时候，如果 a 发生了改变，只需要更新 a 以及用到 a 的 c。由于 b 没有发生改变，所以 Vite 无需重新编译 b，可以从缓存中直接拿编译的结果。这样一来，修改一个文件 a，只会重新编译这个文件 a 以及浏览器当前用到这个文件 a 的文件，而其余文件都无需重新编译。所以理论上热更新的速度不会随着文件增加而变慢。</p> <p><code>缺点： 初始化的时候如果浏览器请求的模块过多，也会带来初始化的性能问题。（热更新的速度会弥补）</code></p> <p><img src="/assets/img/vue_vite_3.7970203b.png" alt=""></p> <p>Webpack 之所以慢，是因为 Webpack 会将许多资源构成一个或者多个 bundle 。如果我们跳过打包的过程，当需要某个模块时再通过请求去获取是不是能完美解决这个问题呢？
<img src="/assets/img/vue_vite_1.3306688c.png" alt=""></p> <h2 id="vite-实现"><a href="#vite-实现" aria-hidden="true" class="header-anchor">#</a> Vite 实现</h2> <h3 id="请求拦截原理"><a href="#请求拦截原理" aria-hidden="true" class="header-anchor">#</a> 请求拦截原理</h3> <p>Vite 的基本实现原理，就是启动一个 koa 服务器拦截浏览器请求ES Module的请求。通过 path 找到目录下对应的文件做一定的处理最终以 ES Modules 格式返回给客户端
<img src="/assets/img/vue_vite_2.f8aeb38f.png" alt=""></p> <h3 id="拦截-http-请求"><a href="#拦截-http-请求" aria-hidden="true" class="header-anchor">#</a> 拦截 HTTP 请求</h3> <p>说一下 Vite 实现的核心——拦截浏览器对模块的请求并返回处理后的结果。</p> <p>起一个本地服务，打开的网页，浏览器发起的第一个请求自然是请求 localhost:xxxx/，这个请求发送到 Vite 后端之后经过静态资源服务器的处理，会进而请求到 /index.html，此时 Vite 就开始对这个请求做拦截和处理了。
首先，index.html 里的源码是这样的：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">&quot;app&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">&quot;module&quot;</span><span class="token operator">&gt;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> createApp <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">import</span> App <span class="token keyword">from</span> <span class="token string">'./App.vue'</span>

<span class="token function">createApp</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">'#app'</span><span class="token punctuation">)</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>但是在浏览器里它是这样的：
<img src="/assets/img/vue_vite_4.aa572e08.png" alt=""></p> <p><code>import { createApp } from 'vue' 换成了 import { createApp } from '/@modules/vue。</code></p> <p>平时我们写代码，如果不是引用相对路径的模块，而是引用 <code>node_modules</code> 的模块，都是直接 <code>import xxx from 'xxx'</code>，由 Webpack 等工具来帮我们找这个模块的具体路径。但是浏览器不知道你项目里有 <code>node_modules</code>，它只能通过相对路径去寻找模块。</p> <p>因此 Vite 在拦截的请求里，对直接引用 <code>node_modules</code> 的模块都做了路径的替换，换成了<code>/@modules/</code> 并返回回去。而后浏览器收到后，会发起对<code>/@modules/xxx</code>的请求，然后被 Vite 再次拦截，并由 Vite 内部去访问真正的模块，并将得到的内容再次做同样的处理后，返回给浏览器。</p> <p>https://juejin.cn/post/6881078539756503047
https://juejin.cn/post/6844904146915573773
https://cn.vitejs.dev/guide/why.html</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">3/10/2021, 3:22:17 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/Vue/three.html" class="prev">
          Vue的编码技巧与规范
        </a></span> <span class="next"><a href="/Serverless/">
          前端开发模式的演进
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a56db5c7.js" defer></script><script src="/assets/js/3.a1556db4.js" defer></script><script src="/assets/js/2.2a730d8e.js" defer></script><script src="/assets/js/4.cf994699.js" defer></script>
  </body>
</html>
